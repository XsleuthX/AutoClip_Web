<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>AutoClip — Web</title>
<style>
  :root{
    --bg-0:#070a0f; --bg-1:#0b1118; --bg-2:#0f1722;
    --panel:#0f141a; --panel-glass:rgba(16,22,29,.6);
    --muted:#9bb3d3; --text:#e7eef7; --stroke:#1e2a38; --stroke-2:#223144;
    --accent:#7c3aed; --accent-2:#06b6d4; --accent-3:#22c55e;
    --warn:#ffd166; --hot:#ff7b72;
  }
  *{box-sizing:border-box} body{
    margin:0; color:var(--text);
    font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    background:
      radial-gradient(60% 80% at 20% 0%, #0a1220 0%, transparent 60%),
      radial-gradient(80% 70% at 100% 0%, #111726 0%, transparent 60%),
      linear-gradient(180deg, var(--bg-0), var(--bg-1));
  }
  header{padding:16px 20px; font-weight:600; letter-spacing:.2px; border-bottom:1px solid var(--stroke);
    background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,0));}
  .panel{
    background:var(--panel-glass); border:1px solid var(--stroke); border-radius:16px; padding:14px;
    box-shadow: inset 0 0 0 1px rgba(255,255,255,.02), 0 10px 30px rgba(0,0,0,.35); position:relative;
  }
  .panel::after{content:""; position:absolute; inset:0; border-radius:16px; pointer-events:none;
    background:linear-gradient(180deg, rgba(124,58,237,.08), rgba(6,182,212,.05)); mix-blend-mode:soft-light;}
  h2{ font-size:13px; letter-spacing:.4px; margin:0 0 10px 0; color:#cfe1f7; opacity:.85; }
  .shell{
    display:grid; grid-template-columns:260px 1fr 360px;
    grid-template-rows: 1fr minmax(180px, 26vh);
    grid-template-areas: "left main right" "left timeline timeline";
    gap:16px; height: calc(100vh - 58px); padding:16px;
  }
  .leftCol{grid-area:left} .mainCol{grid-area:main; display:flex; flex-direction:column; min-height:0}
  .rightCol{grid-area:right; display:flex; flex-direction:column; min-height:0}
  .timelinePanel{grid-area:timeline; display:flex; flex-direction:column; min-height:0}
  button{
    border-width:1px; cursor:pointer; border-radius:32px; padding:10px 14px;
    color:#cfe1f7; background:linear-gradient(180deg, #1c2434, #131b27);
    transition:transform .05s ease, box-shadow .15s ease, background .2s ease;
    box-shadow:0 4px 14px rgba(0,0,0,.28), inset 0 0 0 1px rgba(255,255,255,.06);
  }
  button:hover{ transform:translateY(-1px); } button.secondary{ background:linear-gradient(180deg,#1c2434,#131b27); color:#cfe1f7;}
  .btn{ width:100%; margin:6px 0; }
  .uploader .filebox{ margin-top:8px; padding:8px; min-height:40px; border-radius:12px; border:1px dashed var(--stroke-2); background:rgba(8,12,18,.7); }
  .uploader .filebox small{ color:var(--muted); word-break:break-all; display:block; }
  textarea, select{ width:100%; border-radius:12px; padding:10px 12px; background:#0b0f14; color:#cfe1f7; border:1px solid var(--stroke); }
  .goldrim{ position:relative; width:100%; margin:6px 0; border:2px solid #8a6b2a !important;
    box-shadow:0 4px 14px rgba(0,0,0,.28), inset 0 0 0 1px rgba(255,255,255,.06), 0 0 0 1px rgba(255,209,102,.35); }
  .goldrim:hover{ box-shadow:0 6px 18px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.06), 0 0 0 1px rgba(255,209,102,.55); }
  .video-box{ background:rgba(5,8,13,.7); border:1px solid var(--stroke); border-radius:16px; padding:10px; height:100%; overflow:hidden; }
  .player-wrap{ position:relative; height:100%; min-height:0; }
  video{ width:100%; height:100%; border-radius:12px; background:black; object-fit:contain; display:block; }
  .transport{
    position:absolute; bottom:18px; left:50%; transform:translateX(-50%);
    display:flex; flex-wrap:wrap; gap:8px; align-items:center; justify-content:center;
    padding:8px 10px; border-radius:12px; background:rgba(9,14,22,.8); border:1px solid var(--stroke);
    box-shadow:0 8px 24px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.03); width: clamp(360px, 54%, 680px); backdrop-filter: blur(6px);
  }
  .transport button{ min-width:48px; padding:6px 10px; font-size:12px; line-height:1.2;}
  .transport select{ width:auto; border-radius:10px; padding:6px 8px; background:#111a28; color:#cfe1f7; border:1px solid var(--stroke); }
  .transport .tc{ display:inline-flex; align-items:center; padding:6px 10px; border-radius:10px; border:1px solid var(--stroke); background:rgba(15,22,32,.7);
    font-family:ui-monospace, Menlo, Consolas, monospace; color:#d9e8ff; }
  .srtpanel{ margin-top:10px; padding:8px; border:1px solid var(--stroke); border-radius:12px; background:rgba(9,14,22,.7); min-height:0; overflow:auto; }
  .srtline{ display:flex; gap:10px; padding:8px 10px; border-bottom:1px solid #15202b; align-items:flex-start; cursor:pointer; border-radius:10px; }
  .srtline:hover{ background:rgba(124,58,237,.08); }
  .srtline.active{ background:rgba(255,209,102,.08); outline:2px solid var(--warn); outline-offset:2px; }
  .srtline .tc{ font-family:ui-monospace, Menlo, Consolas, monospace; color:var(--muted); flex:0 0 132px; }
  .srtline .txt{ color:var(--text); white-space:pre-wrap; flex:1 1 auto; }
  .tl-toolbar{ display:flex; align-items:center; gap:8px; margin-bottom:6px; }
  .tl-toolbar .tc{ padding:4px 8px; border:1px solid var(--stroke); border-radius:10px; background:rgba(15,22,32,.7); }
  :root{ --ruler-h:56px; --label-lane:22px; --tick-mid-raise: calc(var(--label-lane)/2); }
  .rulerScroller{ position:relative; overflow:hidden; height:var(--ruler-h); margin-bottom:8px; border-radius:12px; }
  .rulerWrap{ position:relative; height:100%; pointer-events:none; }
  .ruler{ position:relative; height:var(--ruler-h); padding-top:var(--label-lane); box-sizing:border-box; }
  .tick{ position:absolute; top:calc(50% + var(--tick-mid-raise)); transform:translate(-0.5px,-50%); width:1px; height:12px; background:#2b3344; }
  .tick.sec{height:12px;background:#46526c;opacity:.85} .tick.frame{height:6px;background:#3a4358;opacity:.75}
  .tick.major{ height:18px; background:#7280a0; }
  .tick .label{ position:absolute; bottom:calc(100% + 4px); left:50%; transform:translateX(-50%);
    font:12px ui-monospace, Menlo, Consolas; color:#cfe1f7; white-space:nowrap; background:rgba(12,18,26,.7);
    padding:2px 6px; border-radius:8px; border:1px solid var(--stroke);}
  .thumbstrip{ position:relative; height:132px; background:#0b1118; border:1px solid var(--stroke); border-radius:12px;
    overflow-x:auto; overflow-y:hidden; padding:8px 6px; box-sizing:border-box; box-shadow: inset 0 0 0 1px rgba(255,255,255,.02); }
  .thumbwrap{ position:relative; height:100%; } .thumb{ position:absolute; top:50%; transform:translateY(-50%); height:calc(100% / 1.5); object-fit:cover; border-radius:6px; filter:saturate(1.02) contrast(1.02);
    -webkit-user-drag:none; user-select:none; pointer-events:none; }
  .cuts{ position:absolute; inset:0; pointer-events:none; z-index:1; }
  .cut{ position:absolute; top:0; bottom:0; width:2px; background:var(--hot); opacity:.9; }
  .cutLabel{ position:absolute; bottom:calc(100% + 6px); left:50%; transform:translateX(-50%); font:12px ui-monospace, Menlo, Consolas, monospace; color:#cfe1f7; white-space:nowrap; background:rgba(12,18,26,.8); padding:2px 6px; border-radius:8px; border:1px solid var(--stroke); pointer-events:none;}
  .overlay{ position:absolute; inset:0; pointer-events:none; } .playhead{ position:absolute; top:0; bottom:0; width:2px; background:linear-gradient(#ffe08a,#ffd166); box-shadow:0 0 6px rgba(255,224,138,.85); z-index:3; }
  .range{ position:absolute; top:50%; transform:translateY(-50%); height:calc(100% * .85); pointer-events:none;
    background:linear-gradient(180deg, rgba(124,58,237,.18), rgba(6,182,212,.18)); border:2px solid #2b78ff; border-radius:12px; z-index:2;
    box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
    pointer-events:none; /* range body ignores pointer; handles only */
  }
  .range.selected{ border-color:var(--warn); box-shadow:0 0 0 2px rgba(255,209,102,.35) inset, inset 0 0 0 1px rgba(255,255,255,.06); }
  .handle{ position:absolute; top:0; width:10px; height:100%; background:#2b78ff; cursor:ew-resize; pointer-events:auto; }
  .handle.left{ left:-5px; border-radius:8px 0 0 8px; } .handle.right{ right:-5px; border-radius:0 8px 8px 0; }
  .label{ position:absolute; top:4px; left:6px; font-size:12px; background:rgba(12,18,26,.8); padding:2px 6px; border-radius:8px; border:1px solid var(--stroke); color:#d9e8ff; }
  .hint{ color:var(--muted); font-size:12px; }
  .toggle.active{background:linear-gradient(180deg,rgba(124,58,237,.35),rgba(6,182,212,.25));box-shadow:0 0 0 1px rgba(124,58,237,.6) inset}
  .workbar{position:sticky; top:0; z-index:20000; background:#0b0f14; padding:8px 12px; border-bottom:1px solid #243246}
</style>
</head>
<body>
<header><strong>AutoClip</strong> — AI Assisted Timeline Editor (Web)</header>
<div class="workbar" id="workbar" style="display:none">
  <div style="display:grid; grid-template-columns:auto 1fr; align-items:center; gap:12px">
    <div style="font-weight:700; font-size:12px"><span id="worklabel">Working…</span> <span style="opacity:.7">( <span id="workpct">0</span>% )</span></div>
    <div style="height:8px; background:#1a2330; border-radius:999px; overflow:hidden">
      <div id="workfill" style="width:0%; height:100%; background:linear-gradient(90deg, #4facfe, #00f2fe); transition:width 250ms ease"></div>
    </div>
  </div>
</div>

<div class="shell">
  <aside class="leftCol panel">
    <h2>UPLOAD</h2>
    <div class="uploader">
      <input id="mediaInput" type="file" accept="video/*,audio/*" style="display:none"/>
      <input id="srtInput" type="file" accept=".srt" style="display:none"/>
      <button class="btn" id="btnMedia">Media</button>
      <button class="btn" id="btnSrt">SRT</button>
      <div class="filebox"><small id="mediaName">No media selected</small></div>
      <div class="filebox"><small id="srtName">No SRT selected</small></div>
      <button class="goldrim" id="btnLoad">Load</button>
    </div>

    <h2 style="margin-top:14px">Selected clips</h2>
    <div id="clipList" style="height:240px;min-height:60px;max-height:60vh;resize:vertical;overflow:auto;border:1px dashed #1c2633;border-radius:8px;padding:8px"></div>
    <div class="row" style="display:flex; gap:8px; margin-top:10px">
      <button class="secondary" id="btnCreateClip">Create Clip</button>
      <button class="secondary" id="btnDeleteClip" disabled>Delete Clip</button>
    </div>

    <h2 style="margin-top:14px">JSON</h2>
    <textarea id="jsonl" placeholder='{"id":"c1","title":"A","in_ms":2000,"out_ms":7000}\n{"id":"c2","title":"B","in_ms":9000,"out_ms":15000}' style="height:240px;min-height:60px;max-height:60vh;resize:vertical;overflow:auto;border:1px dashed #1c2633;border-radius:8px;padding:8px"></textarea>
    <div class="row" style="display:flex; gap:8px; margin-top:12px">
      <button class="goldrim" id="btnAddTimeline">Add to timeline</button>
      <button class="secondary" id="btnClearClips">Clear</button>
    </div>
    <div style="display:flex; gap:8px; margin-top:0">
      <button class="goldrim" id="btnExportClips">Export clips</button>
    </div>
    <div style="display:flex; gap:8px; margin-top:0">
      <button class="goldrim" id="btnExportCombined">Export clips combined</button>
    </div>
    <div style="display:flex; gap:8px; margin-top:0">
      <button class="goldrim" id="btnExportTimestamps">Export timestamps</button>
    </div>
    <div style="display:flex; gap:8px; margin-top:0">
      <button class="goldrim" id="btnExportJSON">Export JSON</button>
    </div>

    <div style="display:flex; gap:8px; margin-top:0">
      <a class="btn secondary" id="btnDownloadZip" style="display:none" href="#" download>Download zip</a>
    </div>
  </aside>

  <section class="mainCol panel">
    <div class="video-box player-wrap">
      <video id="player" controls></video>

      <div class="transport" id="transport" style="display:none">
        <button id="btnBack1s">⟵ 1s</button>
        <button id="btnPlayPause">Play</button>
        <button id="btnFwd1s">1s ⟶</button>
        <button id="btnPrevFrame">◀︎ Frame</button>
        <button id="btnNextFrame">Frame ▶︎</button>

        <label style="display:inline-flex; gap:6px; align-items:center"><span>Speed</span>
          <select id="selSpeed">
            <option>0.5</option><option>0.75</option><option selected>1</option><option>1.25</option><option>1.5</option><option>2</option>
          </select>
        </label>

        <div class="stackable" style="display:flex; gap:6px">
          <select id="selFps">
            <option>24</option><option>25</option><option selected>30</option><option>50</option><option>60</option>
          </select>
          <div class="tc" id="tcNow">00:00:00:00</div>
        </div>
      </div>
    </div>
  </section>

  <aside class="rightCol panel">
    <h2>SRT</h2>
    <div class="srt-toolbar" style="display:grid; gap:6px; margin-bottom:8px">
      <div style="display:flex; gap:8px; align-items:center">
        <input id="findInput" placeholder="Find…" style="width:120px"/>
        <input id="replaceInput" placeholder="Replace with…" style="width:120px"/>
        <div style="flex:1"></div>
        <button class="goldrim" id="btnExportSrt">Export SRT</button>
      </div>
      <div style="display:flex; gap:12px; align-items:center">
        <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="chkMatchCase"/> Match case</label>
        <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="chkMatchWhole"/> Whole word</label>
      </div>
      <div style="display:flex; gap:8px">
        <button class="secondary" id="btnFindNext">Find Next</button>
        <button class="secondary" id="btnFindPrev">Find Prev</button>
        <button class="secondary" id="btnReplaceAll">Replace All</button>
      </div>
    </div>
    <div class="srtpanel" id="srtpanel"></div>
  </aside>

  <section class="timelinePanel panel">
    <div class="tl-toolbar">
      <button class="secondary" id="btnToggleCuts">Show Scene Cut Markers</button>
      <button class="secondary toggle" id="btnPerSec">Per-Second Marker</button>
      <button class="secondary toggle" id="btnPerFrame">Per-Frame Marker</button>
      <button class="secondary" id="btnStartFrames">Start Frame Export</button>
      <button class="secondary" id="btnMidFrames">Mid Frame Export</button>
      <div style="margin-left:auto; display:flex; gap:8px; align-items:center">
        <span>Zoom</span>
        <button class="secondary" id="btnZoomOut">−</button>
        <div class="tc" id="zoomLabel">×1.00</div>
        <button class="secondary" id="btnZoomIn">+</button>
      </div>
    </div>

    <div class="rulerScroller"><div class="rulerWrap" id="rulerWrap"><div class="ruler" id="ruler"></div></div></div>
    <div class="thumbstrip" id="thumbstrip"><div class="thumbwrap" id="thumbwrap"></div></div>
    <p class="hint" style="margin-top:8px">• Playback: J K L, ←/→  • In: I / Out: O  • Snap: Shift-drag or S  • Zoom: + / −</p>
  </section>
</div>

<!-- JS libs (loaded at runtime when needed): ffmpeg.wasm, JSZip -->
<script>
(function(){
  const $ = (sel, root=document) => root.querySelector(sel);
  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
  const fmt2 = (n)=> String(n).padStart(2,'0');
  let state = {
    videoFile: null, videoUrl: "", srtFile: null, cues: [],
    fps: 30, fpsOverride: null, duration: 0, tMs: 0, zoom: 1,
    thumbs: [], cuts: [], showCuts:false, showPerSecond:false, showPerFrame:false,
    cands: [], selectedId: "", newCounter:1, downloadBlob: null
  };

  const player = $("#player");
  const transport = $("#transport");
  const mediaInput = $("#mediaInput"), srtInput = $("#srtInput");
  $("#btnMedia").onclick = ()=> mediaInput.click();
  $("#btnSrt").onclick = ()=> srtInput.click();
  mediaInput.onchange = (e)=> { const f=e.target.files[0]; state.videoFile=f||null; $("#mediaName").textContent=f?f.name:"No media selected"; };
  srtInput.onchange = (e)=> { const f=e.target.files[0]; state.srtFile=f||null; $("#srtName").textContent=f?f.name:"No SRT selected"; };

  function msToTimecode(ms, fps){
    const totalFrames = Math.round((ms/1000)*fps);
    const h=Math.floor(totalFrames/(fps*3600));
    const m=Math.floor((totalFrames%(fps*3600))/(fps*60));
    const s=Math.floor((totalFrames%(fps*60))/fps);
    const f=totalFrames%fps;
    return `${fmt2(h)}:${fmt2(m)}:${fmt2(s)}:${fmt2(f)}`;
  }
  

// Parse HH:MM:SS:FF using current FPS
function parseTcFF(s, fps){
  const m = /^\s*(\d{1,2}):(\d{2}):(\d{2}):(\d{1,3})\s*$/.exec(String(s||""));
  if(!m) return null;
  const hh = +m[1], mm = +m[2], ss = +m[3], ff = +m[4];
  if(!(isFinite(hh)&&isFinite(mm)&&isFinite(ss)&&isFinite(ff))) return null;
  const F = Math.max(1, +fps||30);
  const ffClamped = Math.min(Math.max(0, ff), F-1);
  const totalFrames = (((hh*60 + mm)*60) + ss)*F + ffClamped;
  return Math.round(totalFrames * (1000/F));
}
function msToSrt(ms){
    const total=Math.max(0, Math.floor(ms));
    const h=Math.floor(total/3600000), m=Math.floor((total%3600000)/60000), s=Math.floor((total%60000)/1000), msr=total%1000;
    return `${fmt2(h)}:${fmt2(m)}:${fmt2(s)},${String(msr).padStart(3,"0")}`;
  }
  
function parseSRT(text){
  const norm = text.replace(/\uFEFF/g, '').replace(/\r\n|\r/g, '\n');
  const blocks = norm.split(/\n\s*\n/);
  const cues = [];
  for (const block of blocks) {
    const lines = block.trim().split('\n').filter(Boolean);
    if (lines.length < 2) continue;
    let i = 0; if (/^\d+$/.test(lines[0].trim())) i = 1;
    const m = /^(\d{2}:\d{2}:\d{2}[,.]\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2}[,.]\d{3})/.exec(lines[i++] || '');
    if (!m) continue;
    const toMs = (s) => {
      const [hh, mm, ssms] = s.split(':');
      const [ss, msRaw] = ssms.split(/[,.]/);
      const ms = (String(msRaw) + '000').slice(0, 3);
      return ((+hh * 60 + +mm) * 60 + +ss) * 1000 + +ms;
    };
    const start_ms = toMs(m[1]);
    const end_ms   = toMs(m[2]);
    const textLines = lines.slice(i);
    cues.push({ start_ms: start_ms, end_ms: end_ms, text: textLines });
  }
  return cues;
}

  $("#btnLoad").onclick = async ()=>{
    if(!state.videoFile){ alert("Select a media file"); return; }
    state.videoUrl = URL.createObjectURL(state.videoFile);
    player.src = state.videoUrl;
    player.load();
    transport.style.display = "flex";
    $("#btnPlayPause").textContent = "Play";
    $("#thumbwrap").innerHTML="";
    $("#ruler").innerHTML="";
    state.cands = []; state.selectedId=""; renderClipList();
    if(state.srtFile){
      const txt = await state.srtFile.text();
      state.cues = parseSRT(txt); renderSrtPanel();
    } else { state.cues=[]; $("#srtpanel").innerHTML=""; }
  };

  
  function renderSrtPanel(){
    const box = $("#srtpanel");
    box.innerHTML = "";
    if(!Array.isArray(state.cues) || !state.cues.length){
      box.innerHTML = '<div class="filebox"><small>No SRT loaded</small></div>';
      return;
    }
    // simple list
    for(let i=0;i<state.cues.length;i++){
      const c = state.cues[i];
      const row = document.createElement('div');
      row.className = "row";
      row.style.cssText = "padding:6px 8px; border-bottom:1px solid #15202b; cursor:pointer; border-radius:8px";
      row.innerHTML = '<div><strong>#'+(i+1)+'</strong></div>' +
        '<div><small>'+msToSrt(c.start_ms)+' → '+msToSrt(c.end_ms)+'</small></div>' +
        '<div><small>'+ (Array.isArray(c.text) ? c.text.join(" / ") : (c.text||"")) +'</small></div>';
      row.onclick = ()=>{ try{ player.currentTime = c.start_ms/1000; }catch{} };
      box.appendChild(row);
    }
  }
player.addEventListener("loadedmetadata", ()=>{
    state.duration = player.duration||0;
    generateThumbnails();
    renderRuler();
    $("#transport").style.display="flex";
  });
  player.addEventListener("timeupdate", ()=>{
    state.tMs = Math.floor((player.currentTime||0)*1000);
    $("#tcNow").textContent = msToTimecode(state.tMs, state.fps);
    updatePlayhead();
    highlightActiveCue();
  });

  $("#btnPlayPause").onclick = ()=>{
    if(player.paused){ player.play(); $("#btnPlayPause").textContent="Pause"; }
    else { player.pause(); $("#btnPlayPause").textContent="Play"; }
  };
  $("#btnBack1s").onclick = ()=> player.currentTime = Math.max(0, player.currentTime-1);
  $("#btnFwd1s").onclick = ()=> player.currentTime = Math.min(state.duration, player.currentTime+1);
  $("#selSpeed").onchange = (e)=> player.playbackRate = parseFloat(e.target.value);
  $("#selFps").onchange = (e)=> { state.fps = parseInt(e.target.value,10)||30; renderRuler(); renderSrtPanel(); };

  $("#btnPrevFrame").onclick = ()=>{ const step=1/(state.fps||30); player.currentTime=Math.max(0,player.currentTime-step); };
  $("#btnNextFrame").onclick = ()=>{ const step=1/(state.fps||30); player.currentTime=Math.min(state.duration,player.currentTime+step); };

  function generateThumbnails(){
    const strip=$('#thumbstrip'), wrap=$('#thumbwrap');
    const hStrip = strip.clientHeight||132, thumbH = Math.max(60, Math.round(hStrip/1.5));
    const canvas=document.createElement('canvas');
    const ar = player.videoWidth && player.videoHeight ? player.videoWidth/player.videoHeight : 16/9;
    canvas.height = thumbH; canvas.width = Math.round(thumbH*ar);
    const ctx = canvas.getContext('2d');
    const baseW = strip.clientWidth || 1200;
    let N = Math.round((baseW*state.zoom)/120); N = Math.max(8, Math.min(48, N||12));
    const seg = (state.duration*1000)/N; state.thumbs=[]; wrap.innerHTML="";
    const wasPaused = player.paused; if(!wasPaused) player.pause();
    const seek = (ms)=> new Promise((res)=>{ const on=()=>{ player.removeEventListener('seeked',on); res(); }; player.addEventListener('seeked',on,{once:true}); player.currentTime=ms/1000; });
    (async ()=>{
      for(let i=0;i<N;i++){
        const t=Math.floor(i*seg); await seek(t);
        try{ ctx.drawImage(player,0,0,canvas.width,canvas.height); const url=canvas.toDataURL("image/jpeg",0.7);
          state.thumbs.push({url,start_ms:t,end_ms:t+seg});
        }catch{}
      }
      if(!wasPaused) player.play();
      renderThumbs();
    })();
  }
  function renderThumbs(){
    const wrap=$("#thumbwrap"); wrap.innerHTML="";
    const widthPx = (wrap.parentElement.clientWidth||1)*state.zoom;
    for(const th of state.thumbs){
      const img=document.createElement('img'); img.className="thumb"; img.src=th.url; img.draggable=false; img.draggable=false;
      const w = ((th.end_ms - th.start_ms) / (state.duration*1000)) * widthPx;
      const l = (th.start_ms / (state.duration*1000)) * widthPx;
      img.style.width=w+"px"; img.style.left=l+"px"; wrap.appendChild(img);
    }
    drawOverlay(); updatePlayhead();
  }
  function updatePlayhead(){
    let ph = $("#playhead"); if(!ph){ ph=document.createElement('div'); ph.id='playhead'; ph.className='playhead'; $("#thumbwrap").appendChild(ph); }
    const widthPx = ($("#thumbwrap").parentElement.clientWidth||1)*state.zoom;
    ph.style.left = ((state.tMs/(state.duration*1000))*widthPx) + "px";
  }

  // Ruler
  function renderRuler(){
    const ruler=$("#ruler"), wrap=$("#rulerWrap"); ruler.innerHTML="";
    wrap.style.width = (state.zoom*100)+"%";
    const visibleSegments = 12*state.zoom;
    const roughStep = state.duration/visibleSegments;
    const choices=[0.1,0.2,0.5,1,2,5,10,15,30,60,120,300];
    let step=choices[0]; for(const c of choices){ step=c; if(roughStep<=c) break; }
    for(let t=0;t<=state.duration;t+=step){
      const leftPct=(t/state.duration)*100;
      const isMajor=Number.isInteger(t/step)&&(Math.round(t/step)%5)===0;
      const div=document.createElement('div'); div.className="tick"+(isMajor?" major":""); div.style.left=leftPct+"%";
      if(isMajor){ const lb=document.createElement('div'); lb.className='label'; lb.textContent = msToTimecode(Math.round(t*1000), state.fps); div.appendChild(lb); }
      ruler.appendChild(div);
    }
    if(state.showPerSecond){
      for(let s=0;s<=state.duration;s+=1){ const d=document.createElement('div'); d.className='tick sec'; d.style.left=((s/state.duration)*100)+"%"; ruler.appendChild(d); }
    }
    if(state.showPerFrame && state.fps>0){
      const totalFrames=Math.max(0,Math.round(state.duration*state.fps)); const budget=4000; const stride=Math.max(1,Math.ceil(totalFrames/budget));
      for(let f=0; f<=totalFrames; f+=stride){ const t=f/state.fps; const d=document.createElement('div'); d.className='tick frame'; d.style.left=((t/state.duration)*100)+"%"; ruler.appendChild(d); }
    }
  }

  // Overlay ranges
  function drawOverlay(){
    let ov=$("#overlay"); if(!ov){ ov=document.createElement('div'); ov.id='overlay'; ov.className='overlay'; $("#thumbwrap").appendChild(ov); }
    ov.innerHTML="";
    const widthPx = ($("#thumbwrap").parentElement.clientWidth||1)*state.zoom;
    for(const c of state.cands){
      const div=document.createElement('div'); div.className='range'+(state.selectedId===c.id?' selected':''); div.style.left=((c.in_ms/(state.duration*1000))*widthPx)+"px";
      div.style.width=(Math.max(12,(c.out_ms-c.in_ms)/(state.duration*1000)*widthPx))+"px";
      div.style.borderColor = c.color || "#2b78ff";
      div.innerHTML = `<div class="label">${c.title}</div>`;
      // range body ignores pointer; selection via handles only.
      // handles
      const hL=document.createElement('div'); hL.className='handle left'; hL.style.background=c.color||"#2b78ff";
      const hR=document.createElement('div'); hR.className='handle right'; hR.style.background=c.color||"#2b78ff";
      div.appendChild(hL); div.appendChild(hR);

      const frameDur = 1000/(state.fps||30);
      function quant(ms){ return Math.round(ms/frameDur)*frameDur; }

      function bindHandle(handle, side){
        handle.onmousedown = (e)=>{
          e.stopPropagation(); e.preventDefault(); selectClip(c.id);
          const startX = e.clientX; const startVal = side==='left' ? c.in_ms : c.out_ms;
          const widthPx2 = ($("#thumbwrap").parentElement.clientWidth||1)*state.zoom;
          const snapAtStart = e.shiftKey; const wasPaused = player.paused; if(!wasPaused) player.pause();
          const onMove = (ev)=>{
            const dx = ev.clientX - startX;
            let newMs = startVal + (dx/widthPx2)*(state.duration*1000);
            if(ev.shiftKey || snapAtStart){
              let best=null, bd=1e9;
              for(const cut of state.cuts){ const d=Math.abs(cut-newMs); if(d<bd && d<=350){ best=cut; bd=d; } }
              if(best!==null) newMs=best;
            }
            newMs = quant(newMs);
            if(side==='left'){ c.in_ms = Math.min(newMs, c.out_ms - frameDur); }
            else { c.out_ms = Math.max(newMs, c.in_ms + frameDur); }
            drawOverlay(); renderClipList();
            if(side==='left'){ player.currentTime = c.in_ms/1000; } else { player.currentTime = c.out_ms/1000; }
          };
          const onUp = ()=>{ window.removeEventListener('mousemove',onMove); window.removeEventListener('mouseup',onUp); if(!wasPaused) player.play(); };
          window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', onUp);
        };
      }
      bindHandle(hL,'left'); bindHandle(hR,'right');
      ov.appendChild(div);
    }
    updatePlayhead();
  }

  // Clip list
  function renderClipList(){
    const listBox = $("#clipList");
    // ensure drop indicator line exists
    let dropLine = $("#clipDropLine");
    if(!dropLine){
      dropLine = document.createElement('div');
      dropLine.id = "clipDropLine";
      dropLine.style.cssText = "position:absolute; left:6px; right:6px; height:0; border-top:2px solid #f2b84b; pointer-events:none; display:none;";
      const wrap = listBox.parentElement;
      // make clip list container positioned
      if(getComputedStyle(listBox).position === "static"){ listBox.style.position = "relative"; }
      listBox.appendChild(dropLine);
    }

    const box=$("#clipList"); box.innerHTML="";
    for(const c of state.cands){
      const row=document.createElement('div');
      row.style.cssText="padding:8px 10px; border-bottom:1px solid #15202b; cursor:pointer; border-radius:8px;"+(state.selectedId===c.id?" background:#132033;":"");
      row.dataset.id = c.id;
      row.onmousedown = (e)=>{
        e.preventDefault();
        const container = $("#clipList");
        // ensure drop line
        let dropLine = $("#clipDropLine");
        if(!dropLine){
          dropLine = document.createElement('div');
          dropLine.id="clipDropLine";
          dropLine.style.cssText="position:absolute; left:6px; right:6px; height:0; border-top:2px solid #f2b84b; pointer-events:none; display:none;";
          if(getComputedStyle(container).position === "static"){ container.style.position="relative"; }
          container.appendChild(dropLine);
        }
        const rows = Array.from(container.children).filter(el => el !== dropLine);
        const startIdx = state.cands.findIndex(x=>x.id===c.id);
        // helpers
        const calcDropIndex = (clientY)=>{
          const els = rows.map(el=>el.getBoundingClientRect());
          const mids = els.map(r => r.top + r.height/2);
          if(!mids.length) return 0;
          if(clientY < mids[0]) return 0;
          for(let i=0;i<mids.length-1;i++){ if(clientY >= mids[i] && clientY < mids[i+1]) return i+1; }
          return mids.length;
        };
        const onMove = (ev)=>{
          const idx = calcDropIndex(ev.clientY);
          dropLine.style.display="block";
          if(rows.length===0){ dropLine.style.top="4px"; return; }
          if(idx >= rows.length){
            const r = rows[rows.length-1].getBoundingClientRect();
            const host = container.getBoundingClientRect();
            dropLine.style.top = (r.bottom - host.top - 8 + container.scrollTop) + "px";
          } else {
            const r = rows[idx].getBoundingClientRect();
            const host = container.getBoundingClientRect();
            dropLine.style.top = (r.top - host.top - 4 + container.scrollTop) + "px";
          }
          row.style.outline="2px solid #f2b84b";
          row.style.boxShadow="0 0 0 2px rgba(242,184,75,0.25) inset";
        };
        const onUp = (ev)=>{
          window.removeEventListener('mousemove', onMove);
          window.removeEventListener('mouseup', onUp);
          dropLine.style.display="none";
          row.style.outline="none";
          row.style.boxShadow="none";
          const idx = calcDropIndex(ev.clientY);
          const from = startIdx, to = idx;
          if(Number.isInteger(from) && Number.isInteger(to) && from !== to){
            const moveItem = (arr, f, t)=>{ const a=arr.slice(); const [x]=a.splice(f,1); const ins = f < t ? Math.max(0, t-1) : t; a.splice(ins,0,x); return a; };
            state.cands = moveItem(state.cands, from, to);
            renderClipList(); drawOverlay();
          }
        };
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp);
      };

      row.onclick = ()=>{ selectClip(c.id); player.currentTime = c.in_ms/1000; };
      const top=document.createElement('div'); top.style.cssText="display:flex; align-items:center; gap:10px";
      const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=!!c.selected;
      cb.onclick = (e)=>{ e.stopPropagation(); c.selected = cb.checked; };
      const title=document.createElement('strong'); title.textContent=c.title;
      title.onclick = (e)=>{
        e.stopPropagation();
        const i=document.createElement('input'); i.value=c.title; i.onkeydown=(ev)=>{ if(ev.key==='Enter'){ c.title=i.value; renderClipList(); drawOverlay(); } if(ev.key==='Escape'){ renderClipList(); } };
        i.onblur=()=>{ c.title=i.value; renderClipList(); drawOverlay(); };
        i.style.cssText="flex:1; border-radius:8px; border:1px solid #243246; padding:6px 8px; background:#0b0f14; color:#cfe1f7";
        top.replaceChild(i,title); i.focus();
      };
      top.appendChild(cb); top.appendChild(title);
      row.appendChild(top);
      const meta=document.createElement('div'); meta.style.marginTop="4px";
      meta.innerHTML=`<small style="font-family:ui-monospace, Menlo, Consolas">${msToTimecode(c.in_ms,state.fps)} → ${msToTimecode(c.out_ms,state.fps)} (${((c.out_ms-c.in_ms)/1000).toFixed(2)}s)</small>`;
      row.appendChild(meta);
      if(state.selectedId===c.id){
        const colorRow=document.createElement('div'); colorRow.style.cssText="margin-top:6px; display:flex; align-items:center; gap:8px";
        colorRow.innerHTML="<small>Range color:</small>";
        const col=document.createElement('input'); col.type='color'; col.value=c.color||"#2b78ff";
        col.onclick=(e)=>e.stopPropagation(); col.oninput=()=>{ c.color=col.value; drawOverlay(); };
        colorRow.appendChild(col); row.appendChild(colorRow);
      }
      box.appendChild(row);
    }
    $("#btnDeleteClip").disabled = !state.selectedId;
  }
  function selectClip(id){ state.selectedId=id; state.cands.forEach(x=>x.selected = x.id===id ? true : x.selected); renderClipList(); drawOverlay(); }

  $("#btnCreateClip").onclick = ()=>{
    if(!state.duration){ alert("Load media first"); return; }
    const id="new_"+Date.now(); const totalMs=Math.floor((state.duration||0)*1000);
    const playhead=Math.max(0, Math.min(totalMs, state.tMs||0)); const span=5000;
    const start=Math.max(0, Math.min(Math.max(0,totalMs-1), Math.min(playhead, Math.max(0,totalMs-span))));
    const end=Math.min(totalMs, start+Math.min(span,totalMs));
    const clip={id, title:`New Clip ${state.newCounter++}`, in_ms:start, out_ms:end, selected:true, color:"#2b78ff"};
    state.cands.push(clip); state.selectedId=id; renderClipList(); drawOverlay();
  };
  $("#btnDeleteClip").onclick = ()=>{ if(!state.selectedId) return; state.cands = state.cands.filter(c=>c.id!==state.selectedId); state.selectedId=""; renderClipList(); drawOverlay(); };
  $("#btnClearClips").onclick = ()=>{ state.cands=[]; state.selectedId=""; renderClipList(); drawOverlay(); };
  $("#btnAddTimeline").onclick = ()=>{
    const el=$("#jsonl"); let s=el.value||""; s=s.replace(/\r\n|\r/g,"\n").replace(/\\n/g,"\n");
    const push=(o)=>{ if(Number.isFinite(o.in_ms)&&Number.isFinite(o.out_ms)){ state.cands.push({ id:o.id||("c_"+(state.cands.length+1)), title:o.title||"Untitled", reason:o.reason||"", score:o.score||0, in_ms:+o.in_ms, out_ms:+o.out_ms, selected:true, color: (typeof o.color==="string" ? o.color : "#2b78ff") }); } };
    try{ const arr=JSON.parse(s); if(Array.isArray(arr)){ arr.forEach(push); renderClipList(); drawOverlay(); return; } }catch{}
    let parts=s.split(/\n+/).map(l=>l.trim()).filter(Boolean);
    if(parts.length===1 && /\}\s*\{/.test(parts[0])) parts = parts[0].replace(/\}\s*\{/g,"}\n{").split(/\n+/);
    for(const ln of parts){ try{ push(JSON.parse(ln)); }catch{} }
    renderClipList(); drawOverlay();
  };

// Thumbstrip navigation (click + drag scrubber)
const thumbstrip = document.querySelector('#thumbstrip');
function clientXToMs(ev){
  const rect = thumbstrip.getBoundingClientRect();
  const widthPx = (rect.width||1)*state.zoom;
  const x = thumbstrip.scrollLeft + (ev.clientX - rect.left);
  const t = Math.max(0, Math.min(state.duration*1000, (x/widthPx)*(state.duration*1000)));
  return t;
}
let scrubbing=false, wasPlaying=false;
thumbstrip.addEventListener('mousedown', (e)=>{
  scrubbing=true; wasPlaying = !player.paused; player.pause();
  const setT = (ev)=>{ const ms = clientXToMs(ev); state.tMs = Math.floor(ms); player.currentTime = ms/1000; updatePlayhead(); };
  setT(e);
  const onMove = (ev)=>{ setT(ev); };
  const onUp = ()=>{ window.removeEventListener('mousemove',onMove); window.removeEventListener('mouseup',onUp); scrubbing=false; if(wasPlaying) player.play(); };
  window.addEventListener('mousemove', onMove);
  window.addEventListener('mouseup', onUp);
});
thumbstrip.addEventListener('click', (e)=>{
  if(scrubbing) return;
  const ms = clientXToMs(e); player.currentTime = ms/1000; updatePlayhead();
});
// Prevent default image drag behavior on timeline
thumbstrip.addEventListener('dragstart', (e)=> e.preventDefault());
  $("#btnZoomIn").onclick = ()=>{ state.zoom=Math.min(8, +(state.zoom*1.25).toFixed(3)); $("#zoomLabel").textContent="×"+state.zoom.toFixed(2); renderRuler(); renderThumbs(); };
  $("#btnZoomOut").onclick = ()=>{ state.zoom=Math.max(0.5, +(state.zoom/1.25).toFixed(3)); $("#zoomLabel").textContent="×"+state.zoom.toFixed(2); renderRuler(); renderThumbs(); };

  // Scene cuts (simple diff-based detector)
  $("#btnToggleCuts").onclick = async ()=>{
    state.showCuts = !state.showCuts;
    $("#btnToggleCuts").textContent = state.showCuts ? "Hide Scene Cut Markers" : "Show Scene Cut Markers";
    if(state.showCuts && state.cuts.length===0){ await detectScenes(); }
    drawCuts(); renderRuler();
  };
  function drawCuts(){
    let layer=$("#cuts"); if(!layer){ layer=document.createElement('div'); layer.id='cuts'; layer.className='cuts'; $("#thumbwrap").appendChild(layer); }
    layer.innerHTML="";
    if(!state.showCuts) return;
    const widthPx = ($("#thumbwrap").parentElement.clientWidth||1)*state.zoom;
    for(const c of state.cuts){
      const left = (c/(state.duration*1000))*widthPx;
      const d=document.createElement('div'); d.className='cut'; d.style.left=left+"px";
      const lab=document.createElement('div'); lab.className='cutLabel'; lab.textContent=msToTimecode(c, state.fps); d.appendChild(lab);
      layer.appendChild(d);
    }
  }
  
async function detectScenes(){
  const W = 160, H = 90;
  const canvas=document.createElement('canvas'); const ctx=canvas.getContext('2d');
  canvas.width=W; canvas.height=H;

  function hist32(imgData){
    const bins = new Array(32).fill(0);
    const d = imgData.data; const n = d.length;
    for(let i=0;i<n;i+=4){
      const y = (0.2126*d[i] + 0.7152*d[i+1] + 0.0722*d[i+2]);
      const b = Math.min(31, (y|0)>>3);
      bins[b]++;
    }
    const total = (imgData.width*imgData.height);
    for(let i=0;i<32;i++) bins[i] /= total;
    return bins;
  }
  function chiAbs(a,b){
    let cs=0, sa=0;
    for(let i=0;i<32;i++){
      const ai=a[i], bi=b[i]; const d=ai-bi;
      cs += (d*d)/(ai+bi+1e-6);
      sa += Math.abs(d);
    }
    return 0.5*cs + 0.5*sa;
  }
  function median(arr){ const s=arr.slice().sort((x,y)=>x-y); const m=Math.floor(s.length/2); return s.length%2?s[m]:(s[m-1]+s[m])/2; }
  function mad(arr, med){ const dev=arr.map(x=>Math.abs(x-med)); return median(dev)||0; }

  const useRVFC = typeof player.requestVideoFrameCallback === 'function';
  const prevPaused = player.paused;
  const prevRate = player.playbackRate;
  const prevT = player.currentTime;

  const scores=[], times=[];
  let prevH=null;

  const processFrame = ()=>{
    ctx.drawImage(player, 0, 0, W, H);
    const h = hist32(ctx.getImageData(0,0,W,H));
    if(prevH){
      const s = chiAbs(prevH, h);
      scores.push(s);
      times.push(player.currentTime*1000|0);
    }
    prevH = h;
  };

  if(useRVFC){
    player.playbackRate = 2.0;
    player.muted = true;
    await new Promise(async (resolve)=>{
      let done=false;
      const cb = ()=>{
        processFrame();
        if(player.currentTime >= (player.duration - 1/ (state.fps||30) - 0.001)){ done=true; }
        if(!done) player.requestVideoFrameCallback(cb); else resolve();
      };
      player.currentTime = 0;
      await player.play().catch(()=>{});
      player.requestVideoFrameCallback(cb);
    });
    player.pause();
  }else{
    const step = 1/(state.fps||30);
    const seek = (t)=> new Promise(res=>{ const on=()=>{ player.removeEventListener('seeked',on); res(); }; player.addEventListener('seeked',on,{once:true}); player.currentTime=t; });
    const wasPaused = player.paused; if(!wasPaused) player.pause();
    for(let t=0; t<=player.duration; t+=step){
      await seek(t);
      processFrame();
    }
    if(!wasPaused) player.play();
  }

  if(scores.length<3){ state.cuts=[]; return; }
  const med = median(scores);
  const m = mad(scores, med);
  const thr = Math.max(med + 6*m, 0.25);

  const cuts=[];
  for(let i=1;i<scores.length-1;i++){
    const s=scores[i];
    if(s>thr && s>scores[i-1] && s>=scores[i+1]) cuts.push(times[i]);
  }
  state.cuts = cuts;

  player.playbackRate = prevRate;
  if(!prevPaused){ await player.play().catch(()=>{}); } else { player.pause(); }
  player.currentTime = prevT;
}
  function highlightActiveCue(){
    const idx = state.cues.findIndex(c=> state.tMs>=c.start_ms && state.tMs< c.end_ms-2 );
    const rows = $$("#srtpanel .srtline");
    rows.forEach(r=> r.classList.remove('active'));
    if(idx>=0){ rows[idx]?.classList.add('active'); rows[idx]?.scrollIntoView({block:"center"}); }
  }
  $("#btnExportSrt").onclick = ()=>{
    if(!state.cues.length){ alert("No SRT loaded"); return; }
    const lines=[];
    for(let i=0;i<state.cues.length;i++){
      const c=state.cues[i];
      lines.push(String(i+1));
      lines.push(msToSrt(c.start_ms)+" --> "+msToSrt(c.end_ms));
      lines.push((Array.isArray(c.text)?c.text.join("\n"):String(c.text||"")));
      lines.push("");
    }
    const blob=new Blob([lines.join("\n")],{type:"text/plain;charset=utf-8"});
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download="subtitles_edited.srt"; document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(a.href),750);
  };
  // Find/Replace
  function getFindHaystack(s){ return $("#chkMatchCase").checked ? s : s.toLowerCase(); }
  function getFindQ(){ const q=$("#findInput").value||""; return $("#chkMatchCase").checked ? q : q.toLowerCase(); }
  function gotoCue(i){ if(i<0 || i>=state.cues.length) return; findIdx=i; player.currentTime=(state.cues[i].start_ms+2)/1000; const rows=$$("#srtpanel .srtline"); rows[i]?.scrollIntoView({block:"center"}); }
  $("#btnFindNext").onclick = ()=>{
    const q=getFindQ(); if(!q){ findIdx=-1; return; } let start=(findIdx+1)%state.cues.length, idx=-1;
    for(let k=0;k<state.cues.length;k++){ const i=(start+k)%state.cues.length; const body=getFindHaystack(state.cues[i].text.join("\n"));
      if($("#chkMatchWhole").checked){ const re=new RegExp(`(^|\\b)${q.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}(\\b|$)`); if(re.test(body)){ idx=i; break; } }
      else if(body.includes(q)){ idx=i; break; }
    } if(idx>=0) gotoCue(idx); else alert("No more matches.");
  };
  $("#btnFindPrev").onclick = ()=>{
    const q=getFindQ(); if(!q){ findIdx=-1; return; } let start=(findIdx-1+state.cues.length)%state.cues.length, idx=-1;
    for(let k=0;k<state.cues.length;k++){ const i=(start-k+state.cues.length*2)%state.cues.length; const body=getFindHaystack(state.cues[i].text.join("\n"));
      if($("#chkMatchWhole").checked){ const re=new RegExp(`(^|\\b)${q.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}(\\b|$)`); if(re.test(body)){ idx=i; break; } }
      else if(body.includes(q)){ idx=i; break; }
    } if(idx>=0) gotoCue(idx); else alert("No previous matches.");
  };
  $("#btnReplaceAll").onclick = ()=>{
    const q=$("#findInput").value; if(!q) return; const esc=(s)=>s.replace(/[.*+?^${}()|[\]\\]/g,"\\$&");
    const flags=$("#chkMatchCase").checked?"g":"gi"; const re=$("#chkMatchWhole").checked ? new RegExp(`(^|\\b)${esc(q)}(\\b|$)`,flags) : new RegExp(esc(q),flags);
    state.cues = state.cues.map(c=> ({...c, text: c.text.map(line => line.replace(re, $("#replaceInput").value))})); renderSrtPanel();
  };

  // Export timestamps
  $("#btnExportTimestamps").onclick = ()=>{
    const selected = state.cands.filter(c=>c.selected);
    if(!selected.length){ alert("No clips selected."); return; }
    const rows=[["filename","clip_title","timecode_in","timecode_out"].join(",")];
    const baseName = (state.videoFile?.name||"video").replace(/\.[^.]+$/,"");
    const esc=(s)=>'"'+String(s).replace(/"/g,'""')+'"';
    for(const c of selected){ rows.push([esc(baseName), esc(c.title||""), esc(msToTimecode(c.in_ms,state.fps)), esc(msToTimecode(c.out_ms,state.fps))].join(",")); }
    const blob=new Blob([rows.join("\n")+"\n"],{type:"text/csv;charset=utf-8"});
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=baseName+"_timestamps.csv"; document.body.appendChild(a); a.click(); a.remove();
  };

  // Export JSON prompt (selected clips in order)
  $("#btnExportJSON").onclick = ()=>{
    const selected = state.cands.filter(c=>c.selected);
    if(!selected.length){ alert("No clips selected."); return; }
    const payload = selected.map(c => ({
      id: c.id,
      title: c.title || "Untitled",
      reason: c.reason || "",
      score: Number.isFinite(c.score) ? c.score : 0,
      in_ms: Math.floor(c.in_ms),
      out_ms: Math.floor(c.out_ms),
      selected: true,
      color: c.color || "#2b78ff",
    }));
    const json = JSON.stringify(payload, null, 2);
    const baseName = (state.videoFile?.name||"video").replace(/\.[^.]+$/,"");
    const blob = new Blob([json], {type:"application/json"});
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=baseName+"_clips.json"; document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(a.href), 750);
  };


  // Export frames (canvas snapshots)
  $("#btnStartFrames").onclick = ()=> exportFrames('start');
  $("#btnMidFrames").onclick = ()=> exportFrames('mid');
  async function exportFrames(mode){
    if(!state.duration){ alert("Load media first"); return; }
    const zip = new JSZip();
    const canvas=document.createElement('canvas'); const ctx=canvas.getContext('2d');
    const W=player.videoWidth, H=player.videoHeight; canvas.width=W; canvas.height=H;
    // Derive scene boundaries from cuts or fallback to N chunks
    let bounds=[0, ...state.cuts, Math.floor(state.duration*1000)];
    if(bounds.length<=2){ const N=10; const seg=Math.floor(state.duration*1000/N); bounds=[0]; for(let i=1;i<=N;i++) bounds.push(seg*i); }
    const seek = (ms)=> new Promise((res)=>{ const on=()=>{ player.removeEventListener('seeked',on); setTimeout(res,20); }; player.addEventListener('seeked',on,{once:true}); player.currentTime=ms/1000; });
    const wasPaused = player.paused; if(!wasPaused) player.pause();
    for(let i=0;i<bounds.length-1;i++){
      const a=bounds[i], b=bounds[i+1]; const t = mode==='start' ? a+30 : Math.floor((a+b)/2);
      await seek(t);
      ctx.drawImage(player,0,0,W,H);
      const blob = await new Promise(res=> canvas.toBlob(res, "image/jpeg", 0.9) );
      zip.file(`scene_${String(i+1).padStart(3,'0')}_${mode}.jpg`, blob);
    }
    if(!wasPaused) player.play();
    const out = await zip.generateAsync({type:"blob"});
    const a=document.createElement('a'); a.href=URL.createObjectURL(out); a.download=`frames_${mode}.zip`; document.body.appendChild(a); a.click(); a.remove();
  }

  // ffmpeg.wasm helpers (loaded on demand)
  let ffmpeg=null;
  async function ensureFFmpeg(){
    if(ffmpeg) return ffmpeg;
    showWork("Loading encoder…");
    // load UMD bundle to get global FFmpeg
    await new Promise((resolve, reject)=>{
      const s = document.createElement('script');
      s.src = "https://unpkg.com/@ffmpeg/ffmpeg@0.12.6/dist/umd/index.js";
      s.onload = resolve;
      s.onerror = ()=>reject(new Error("Failed to load FFmpeg UMD"));
      document.head.appendChild(s);
    });
    if(!window.FFmpeg){ hideWork(); throw new Error("FFmpeg global not found"); }
    const { createFFmpeg, fetchFile } = window.FFmpeg;
    ffmpeg = createFFmpeg({ log: true, corePath: "https://unpkg.com/@ffmpeg/core@0.12.6/dist/umd/ffmpeg-core.js" });
    await ffmpeg.load();
    hideWork();
    return ffmpeg;
  }


  // Export clips via ffmpeg.wasm (separate files zipped)
  $("#btnExportClips").onclick = async ()=>{
    const selected = state.cands.filter(c=>c.selected);
    if(!selected.length){ alert("No clips selected."); return; }
    const base = prompt("Enter base file name for the selected clips (no extension):", "clips"); if(base==null) return;
    const baseName = String(base).trim().replace(/[\/:*?\"<>|]+/g,"_"); if(!baseName){ alert("Filename cannot be empty."); return; }
    const ff = await ensureFFmpeg();
    showWork("Transcoding clips…");
    // Write input file
    const inName = "input.mp4";
    const buf = await state.videoFile.arrayBuffer();
    ff.FS("writeFile", inName, new Uint8Array(buf));
    const zip = new JSZip();
    for(let i=0;i<selected.length;i++){
      const c=selected[i];
      const out = `${baseName}_${String(i+1).padStart(2,'0')}.mp4`;
      const ss = (c.in_ms/1000).toFixed(3);
      const to = Math.max(0,(c.out_ms-c.in_ms)/1000).toFixed(3);
      $("#worklabel").textContent = `Clip ${i+1}/${selected.length}`;
      $("#workpct").textContent = Math.round((i/selected.length)*100);
      $("#workfill").style.width = (i/selected.length*100)+"%";
      await ff.run("-ss", ss, "-i", inName, "-t", to, "-c:v", "libx264", "-preset", "veryfast", "-crf", "23", "-c:a", "aac", "-b:a", "128k", out);
      const data = ff.FS("readFile", out);
      zip.file(out, data);
      ff.FS("unlink", out);
    }
    const outZip = await zip.generateAsync({type:"blob"});
    hideWork();
    const url = URL.createObjectURL(outZip);
    const a=$("#btnDownloadZip"); a.style.display="inline-block"; a.href=url; a.download=baseName+"_clips.zip"; a.textContent="Download zip";
  };

  // Export combined
  $("#btnExportCombined").onclick = async ()=>{
    const selected = state.cands.filter(c=>c.selected);
    if(!selected.length){ alert("No clips selected."); return; }
    const name = prompt("Enter file name for the combined video (no extension):", "combined"); if(name==null) return;
    const fname = String(name).trim().replace(/[\/:*?\"<>|]+/g,"_"); if(!fname){ alert("Filename cannot be empty."); return; }
    const ff = await ensureFFmpeg(); showWork("Rendering combined…");
    const inName="input.mp4"; const buf=await state.videoFile.arrayBuffer(); ff.FS("writeFile", inName, new Uint8Array(buf));
    // render parts into temp files, then concat
    const parts=[];
    for(let i=0;i<selected.length;i++){
      const c=selected[i]; const out=`part_${i}.mp4`; const ss=(c.in_ms/1000).toFixed(3); const to=((c.out_ms-c.in_ms)/1000).toFixed(3);
      await ff.run("-ss", ss, "-i", inName, "-t", to, "-c:v", "libx264", "-preset", "veryfast", "-crf", "23", "-c:a", "aac", "-b:a", "128k", out);
      parts.push(out);
    }
    // concat demuxer requires a list file
    const listTxt = parts.map(p=>`file '${p}'`).join("\n"); ff.FS("writeFile", "list.txt", new TextEncoder().encode(listTxt));
    const outName = fname + ".mp4";
    await ff.run("-f","concat","-safe","0","-i","list.txt","-c","copy", outName);
    const data=ff.FS("readFile", outName); hideWork();
    const blob=new Blob([data.buffer],{type:"video/mp4"});
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=outName; document.body.appendChild(a); a.click(); a.remove();
  };

  // Workbar
  function showWork(label){ $("#workbar").style.display="block"; $("#worklabel").textContent=label||"Working…"; $("#workpct").textContent="0"; $("#workfill").style.width="0%"; }
  function hideWork(){ $("#workbar").style.display="none"; }

  // Keyboard shortcuts
  window.addEventListener("keydown", (e)=>{
    if(document.activeElement && (document.activeElement.tagName==="INPUT" || document.activeElement.tagName==="TEXTAREA")) return;
    switch(e.key.toLowerCase()){
      case "j": player.currentTime=Math.max(0,player.currentTime-1); break;
      case "k": if(player.paused) player.play(); else player.pause(); break;
      case "l": player.currentTime=Math.min(state.duration,player.currentTime+1); break;
      case "arrowleft": e.preventDefault(); player.currentTime=Math.max(0, player.currentTime-1/(state.fps||30)); break;
      case "arrowright": e.preventDefault(); player.currentTime=Math.min(state.duration, player.currentTime+1/(state.fps||30)); break;
      case "=": case "+": $("#btnZoomIn").click(); break;
      case "-": case "_": $("#btnZoomOut").click(); break;
      case "i": { const sel=state.cands.find(x=>x.id===state.selectedId); if(sel){ const cur=Math.floor(player.currentTime*1000); sel.in_ms=Math.min(cur, sel.out_ms-50); drawOverlay(); renderClipList(); } } break;
      case "o": { const sel=state.cands.find(x=>x.id===state.selectedId); if(sel){ const cur=Math.floor(player.currentTime*1000); sel.out_ms=Math.max(cur, sel.in_ms+50); drawOverlay(); renderClipList(); } } break;
      case "s": { const sel=state.cands.find(x=>x.id===state.selectedId); if(sel){ const ni=nearestCut(sel.in_ms), no=nearestCut(sel.out_ms); sel.in_ms=ni??sel.in_ms; sel.out_ms=no??sel.out_ms; drawOverlay(); renderClipList(); } } break;
    }
  });
  function nearestCut(ms, tol=350){ if(!state.cuts.length) return null; let best=null, bd=1e9; for(const c of state.cuts){ const d=Math.abs(c-ms); if(d<bd && d<=tol){ best=c; bd=d; } } return best; }

  // Per-second / per-frame toggles
  $("#btnPerSec").onclick = (e)=>{ state.showPerSecond = !state.showPerSecond; e.currentTarget.classList.toggle('active', state.showPerSecond); renderRuler(); };
  $("#btnPerFrame").onclick = (e)=>{ state.showPerFrame = !state.showPerFrame; e.currentTarget.classList.toggle('active', state.showPerFrame); renderRuler(); };

function srtTimeToMs(s){
  const m = /^\s*(\d{1,2}):(\d{2}):(\d{2})[,.](\d{1,3})\s*$/.exec(String(s||""));
  if(!m) return null;
  const [_,hh,mm,ss,ms] = m;
  const msPad = String(ms).padEnd(3,"0").slice(0,3);
  return ((+hh*60+ +mm)*60+ +ss)*1000 + (+msPad);
}

})();
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</body>
</html>
